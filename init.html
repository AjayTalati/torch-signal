<p><a name="signal.fft"></a></p>

<h3>signal.fft(input)</h3>

<p>1D FFT
   Takes Real inputs (1D tensor of N points)
   or complex inputs 2D tensor of (Nx2) size for N points</p>

<p>Output matches with matlab output
<a name="signal.ifft"></a></p>

<h3>signal.ifft(input)</h3>

<p>inverse 1D FFT
   Takes Real inputs (1D tensor of N points)
   or complex inputs 2D tensor of (Nx2) size for N points</p>

<p>Output matches with matlab output
<a name="signal.rfft"></a></p>

<h3>signal.rfft(inp)</h3>

<p>real to complex dft.
   This function retains only the positive frequencies.
   Input is a 1D real tensor
   Output is 2D complex tensor of size (input:size(1)/2 + 1, 2)
<a name="signal.irfft"></a></p>

<h3>signal.irfft(inp)</h3>

<p>complex to real dft. This function is the exact inverse of signal.rfft
<a name="signal.fft2"></a></p>

<h3>signal.fft2(input)</h3>

<p>2D FFT
   Takes Real inputs (2D tensor of NxM points)
   or complex inputs 3D tensor of (NxMx2) size for NxM points</p>

<p>Output matches with matlab output
<a name="signal.ifft2"></a></p>

<h3>signal.ifft2(input)</h3>

<p>2D Inverse FFT
   Takes Real inputs (2D tensor of NxM points)
   or complex inputs 3D tensor of (NxMx2) size for NxM points</p>

<p>Output matches with matlab output
<a name="signal.fft3"></a></p>

<h3>signal.fft3(input)</h3>

<p>3D FFT
   Takes Real inputs (3D tensor of NxMxP points)
   or complex inputs 4D tensor of (NxMxPx2) size for NxMxP points</p>

<p>Output matches with matlab output
<a name="signal.ifft3"></a></p>

<h3>signal.ifft3(input)</h3>

<p>3D Inverse FFT
   Takes Real inputs (3D tensor of NxMxP points)
   or complex inputs 4D tensor of (NxMxPx2) size for NxMxP points</p>

<p>Output matches with matlab output
<a name="signal.stft"></a></p>

<h3>signal.stft(inp, window_size, window_stride, window_type)</h3>

<p>1D short-time fourier transforms
   Run a window across your signal and calculate fourier transforms on that window.
   To make sure that the windows are not discontinuous at the edges, you can optionally apply a window preprocessor.
   The available window preprocessors are: hamming, hann, bartlett
<a name="signal.spectrogram"></a></p>

<h3>signal.spectrogram(inp, window_size, window_stride)</h3>

<p>Takes the stft and generates a pretty spectrogram by
   taking the magnitude of the stft, and applying a (natural log * 10)
   Also transposes the output, to have time on the X axis.
<a name="signal.unwrap"></a></p>

<h3>signal.unwrap(a, tol)</h3>

<p>Correct phase angles to produce smoother phase plots<br>
   Unwrap radian phases by adding multiples of 2*pi as appropriate to
   remove jumps greater than <strong>tol</strong>. <strong>tol</strong> defaults to pi.   </p>

<p>Output matches with matlab output
<a name="signal.rcunwrap"></a></p>

<h3>signal.rcunwrap(x)</h3>

<p>unwraps the phase and removes phase corresponding to integer lag.</p>

<p>Output matches with matlab output
<a name="signal.rcwrap"></a></p>

<h3>signal.rcwrap(y, nd)</h3>

<p>Adds phase corresponding to integer lag</p>

<p>Output matches with matlab output
<a name="signal.cceps"></a></p>

<h3>signal.cceps(x)</h3>

<p>1D Complex cepstral analysis
   Returns the cepstrum and a phase shift factor &quot;nd&quot; that is useful to invert the signal back.</p>

<p>Output matches with matlab output
<a name="signal.icceps"></a></p>

<h3>signal.icceps(xhat,nd)</h3>

<p>1D Inverse Complex cepstral analysis.
   Takes in the outputs of cceps to produce the input signal back</p>

<p>Output matches with matlab output
<a name="signal.rceps"></a></p>

<h3>signal.rceps(x)</h3>

<p>Real cepstrum and minimum phase reconstruction
   The real cepstrum is the inverse Fourier transform of the real logarithm of the magnitude of the Fourier transform of a sequence.</p>

<p>Output matches with matlab output
<a name="signal.dct"></a></p>

<h3>signal.dct(input)</h3>

<p>1D Discrete Cosine Transform (DCT)
   Takes Real inputs (1D tensor of N points)</p>

<p>To see what is exactly computed, see section REDFT10 over here: 
   <a href="http://www.fftw.org/doc/1d-Real_002deven-DFTs-_0028DCTs_0029.html">http://www.fftw.org/doc/1d-Real_002deven-DFTs-_0028DCTs_0029.html</a>
<a name="signal.idct"></a></p>

<h3>signal.idct(input)</h3>

<p>inverse 1D Discrete Cosine Transform (DCT)
   Takes Real inputs (1D tensor of N points)</p>

<p>To see what is exactly computed, see section REDFT01 over here: 
   <a href="http://www.fftw.org/doc/1d-Real_002deven-DFTs-_0028DCTs_0029.html">http://www.fftw.org/doc/1d-Real_002deven-DFTs-_0028DCTs_0029.html</a>
<a name="signal.dct2"></a></p>

<h3>signal.dct2(input)</h3>

<p>2D Discrete Cosine Transform (DCT)
   Takes Real inputs (2D tensor of NxM points)</p>

<p>To see what is exactly computed, see section REDFT10 over here: 
   <a href="http://www.fftw.org/doc/1d-Real_002deven-DFTs-_0028DCTs_0029.html">http://www.fftw.org/doc/1d-Real_002deven-DFTs-_0028DCTs_0029.html</a>
<a name="signal.idct2"></a></p>

<h3>signal.idct2(input)</h3>

<p>inverse 2D Discrete Cosine Transform (DCT)
   Takes Real inputs (2D tensor of NxM points)</p>

<p>To see what is exactly computed, see section REDFT01 over here: 
   <a href="http://www.fftw.org/doc/1d-Real_002deven-DFTs-_0028DCTs_0029.html">http://www.fftw.org/doc/1d-Real_002deven-DFTs-_0028DCTs_0029.html</a>
<a name="signal.dct3"></a></p>

<h3>signal.dct3(input)</h3>

<p>3D Discrete Cosine Transform (DCT)
   Takes Real inputs (3D tensor of NxMXP points)</p>

<p>To see what is exactly computed, see section REDFT10 over here: 
   <a href="http://www.fftw.org/doc/1d-Real_002deven-DFTs-_0028DCTs_0029.html">http://www.fftw.org/doc/1d-Real_002deven-DFTs-_0028DCTs_0029.html</a>
<a name="signal.idct3"></a></p>

<h3>signal.idct3(input)</h3>

<p>inverse 3D Discrete Cosine Transform (DCT)
   Takes Real inputs (3D tensor of NxMxP points)</p>

<p>To see what is exactly computed, see section REDFT01 over here: 
   <a href="http://www.fftw.org/doc/1d-Real_002deven-DFTs-_0028DCTs_0029.html">http://www.fftw.org/doc/1d-Real_002deven-DFTs-_0028DCTs_0029.html</a>
<a name="signal.hilbert"></a></p>

<h3>signal.hilbert(xr)</h3>

<p>Discrete-time analytic signal using Hilbert transform
   Takes 1D inputs</p>

<p>Output matches with matlab output</p>
