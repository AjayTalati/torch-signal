<html>
<head>
<link rel="stylesheet" type="text/css" href="style.css">
<title>signal - Documentation</title>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          skipTags: ['script', 'noscript', 'style', 'textarea'],
          displayMath: [['$${', '}$$']],
          inlineMath: [['${', '}$']]
      }
  });
  MathJax.Hub.Queue(function() {
      // Fix <code> tags after MathJax finishes running. This is a
      // hack to overcome a shortcoming of Markdown. Discussion at
      // https://github.com/mojombo/jekyll/issues/199
      var all = MathJax.Hub.getAllJax(), i;
      for(i = 0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<link rel="stylesheet" href="../_highlight/styles/github.css">
<script type="text/javascript" src="../_highlight/highlight.pack.js"></script>
<script src="http://code.jquery.com/jquery-1.10.1.min.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        $('pre code').each(function(i, e) {
            var par = $(e).closest('pre');
            if (! $(par).hasClass('has-jax')) {
                hljs.highlightBlock(e);
            }
        });
    });
</script>



<script src="../search.js"></script>
<script type="text/javascript"> addSearchFormHeader(); </script>
</head>
<body>
<header>
<ul>Navigation:
<li><a href="../index.html">research-docs</a></li>
<li><a href="https://github.com/">signal github</a></li>
<li><a href="#">top of this page</a></li>
</ul>
</header>
<div class="wrapper">
<div id="navcontainer"><ul>
<li><a href="#signal.init.dok">init</a>
<ul>
<li><a href="#signal.fft">signal.fft</a></li>
<li><a href="#signal.ifft">signal.ifft</a></li>
<li><a href="#signal.rfft">signal.rfft</a></li>
<li><a href="#signal.irfft">signal.irfft</a></li>
<li><a href="#signal.fft2">signal.fft2</a></li>
<li><a href="#signal.ifft2">signal.ifft2</a></li>
<li><a href="#signal.fft3">signal.fft3</a></li>
<li><a href="#signal.ifft3">signal.ifft3</a></li>
<li><a href="#signal.stft">signal.stft</a></li>
<li><a href="#signal.spectrogram">signal.spectrogram</a></li>
<li><a href="#signal.unwrap">signal.unwrap</a></li>
<li><a href="#signal.rcunwrap">signal.rcunwrap</a></li>
<li><a href="#signal.rcwrap">signal.rcwrap</a></li>
<li><a href="#signal.cceps">signal.cceps</a></li>
<li><a href="#signal.icceps">signal.icceps</a></li>
<li><a href="#signal.rceps">signal.rceps</a></li>
<li><a href="#signal.dct">signal.dct</a></li>
<li><a href="#signal.idct">signal.idct</a></li>
<li><a href="#signal.dct2">signal.dct2</a></li>
<li><a href="#signal.idct2">signal.idct2</a></li>
<li><a href="#signal.dct3">signal.dct3</a></li>
<li><a href="#signal.idct3">signal.idct3</a></li>
<li><a href="#signal.hilbert">signal.hilbert</a></li>
</ul>
</li>
</ul>
</div>
<section>
<div class='docSection'><a name="signal.README.dok"></a><h1>torch-signal</h1>

<p>For documentation, go to:</p>

<p><a href="http://soumith.github.io/torch-signal/">http://soumith.github.io/torch-signal/</a></p>
</div><div class='docSection'><a name="signal.init.dok"></a><p><a name="signal.fft"></a></p>

<h3>signal.fft(input)</h3>

<p>1D FFT
   Takes Real inputs (1D tensor of N points)
   or complex inputs 2D tensor of (Nx2) size for N points</p>

<p>Output matches with matlab output
<a name="signal.ifft"></a></p>

<h3>signal.ifft(input)</h3>

<p>inverse 1D FFT
   Takes Real inputs (1D tensor of N points)
   or complex inputs 2D tensor of (Nx2) size for N points</p>

<p>Output matches with matlab output
<a name="signal.rfft"></a></p>

<h3>signal.rfft(inp)</h3>

<p>real to complex dft.
   This function retains only the positive frequencies.
   Input is a 1D real tensor
   Output is 2D complex tensor of size (input:size(1)/2 + 1, 2)
<a name="signal.irfft"></a></p>

<h3>signal.irfft(inp)</h3>

<p>complex to real dft. This function is the exact inverse of signal.rfft
<a name="signal.fft2"></a></p>

<h3>signal.fft2(input)</h3>

<p>2D FFT
   Takes Real inputs (2D tensor of NxM points)
   or complex inputs 3D tensor of (NxMx2) size for NxM points</p>

<p>Output matches with matlab output
<a name="signal.ifft2"></a></p>

<h3>signal.ifft2(input)</h3>

<p>2D Inverse FFT
   Takes Real inputs (2D tensor of NxM points)
   or complex inputs 3D tensor of (NxMx2) size for NxM points</p>

<p>Output matches with matlab output
<a name="signal.fft3"></a></p>

<h3>signal.fft3(input)</h3>

<p>3D FFT
   Takes Real inputs (3D tensor of NxMxP points)
   or complex inputs 4D tensor of (NxMxPx2) size for NxMxP points</p>

<p>Output matches with matlab output
<a name="signal.ifft3"></a></p>

<h3>signal.ifft3(input)</h3>

<p>3D Inverse FFT
   Takes Real inputs (3D tensor of NxMxP points)
   or complex inputs 4D tensor of (NxMxPx2) size for NxMxP points</p>

<p>Output matches with matlab output
<a name="signal.stft"></a></p>

<h3>signal.stft(inp, window_size, window_stride, window_type)</h3>

<p>1D short-time fourier transforms
   Run a window across your signal and calculate fourier transforms on that window.
   To make sure that the windows are not discontinuous at the edges, you can optionally apply a window preprocessor.
   The available window preprocessors are: hamming, hann, bartlett
<a name="signal.spectrogram"></a></p>

<h3>signal.spectrogram(inp, window_size, window_stride)</h3>

<p>Takes the stft and generates a pretty spectrogram by
   taking the magnitude of the stft, and applying a (natural log * 10)
   Also transposes the output, to have time on the X axis.
<a name="signal.unwrap"></a></p>

<h3>signal.unwrap(a, tol)</h3>

<p>Correct phase angles to produce smoother phase plots<br>
   Unwrap radian phases by adding multiples of 2*pi as appropriate to
   remove jumps greater than <strong>tol</strong>. <strong>tol</strong> defaults to pi.   </p>

<p>Output matches with matlab output
<a name="signal.rcunwrap"></a></p>

<h3>signal.rcunwrap(x)</h3>

<p>unwraps the phase and removes phase corresponding to integer lag.</p>

<p>Output matches with matlab output
<a name="signal.rcwrap"></a></p>

<h3>signal.rcwrap(y, nd)</h3>

<p>Adds phase corresponding to integer lag</p>

<p>Output matches with matlab output
<a name="signal.cceps"></a></p>

<h3>signal.cceps(x)</h3>

<p>1D Complex cepstral analysis
   Returns the cepstrum and a phase shift factor &quot;nd&quot; that is useful to invert the signal back.</p>

<p>Output matches with matlab output
<a name="signal.icceps"></a></p>

<h3>signal.icceps(xhat,nd)</h3>

<p>1D Inverse Complex cepstral analysis.
   Takes in the outputs of cceps to produce the input signal back</p>

<p>Output matches with matlab output
<a name="signal.rceps"></a></p>

<h3>signal.rceps(x)</h3>

<p>Real cepstrum and minimum phase reconstruction
   The real cepstrum is the inverse Fourier transform of the real logarithm of the magnitude of the Fourier transform of a sequence.</p>

<p>Output matches with matlab output
<a name="signal.dct"></a></p>

<h3>signal.dct(input)</h3>

<p>1D Discrete Cosine Transform (DCT)
   Takes Real inputs (1D tensor of N points)</p>

<p>To see what is exactly computed, see section REDFT10 over here: 
   <a href="http://www.fftw.org/doc/1d-Real_002deven-DFTs-_0028DCTs_0029.html">http://www.fftw.org/doc/1d-Real_002deven-DFTs-_0028DCTs_0029.html</a>
<a name="signal.idct"></a></p>

<h3>signal.idct(input)</h3>

<p>inverse 1D Discrete Cosine Transform (DCT)
   Takes Real inputs (1D tensor of N points)</p>

<p>To see what is exactly computed, see section REDFT01 over here: 
   <a href="http://www.fftw.org/doc/1d-Real_002deven-DFTs-_0028DCTs_0029.html">http://www.fftw.org/doc/1d-Real_002deven-DFTs-_0028DCTs_0029.html</a>
<a name="signal.dct2"></a></p>

<h3>signal.dct2(input)</h3>

<p>2D Discrete Cosine Transform (DCT)
   Takes Real inputs (2D tensor of NxM points)</p>

<p>To see what is exactly computed, see section REDFT10 over here: 
   <a href="http://www.fftw.org/doc/1d-Real_002deven-DFTs-_0028DCTs_0029.html">http://www.fftw.org/doc/1d-Real_002deven-DFTs-_0028DCTs_0029.html</a>
<a name="signal.idct2"></a></p>

<h3>signal.idct2(input)</h3>

<p>inverse 2D Discrete Cosine Transform (DCT)
   Takes Real inputs (2D tensor of NxM points)</p>

<p>To see what is exactly computed, see section REDFT01 over here: 
   <a href="http://www.fftw.org/doc/1d-Real_002deven-DFTs-_0028DCTs_0029.html">http://www.fftw.org/doc/1d-Real_002deven-DFTs-_0028DCTs_0029.html</a>
<a name="signal.dct3"></a></p>

<h3>signal.dct3(input)</h3>

<p>3D Discrete Cosine Transform (DCT)
   Takes Real inputs (3D tensor of NxMXP points)</p>

<p>To see what is exactly computed, see section REDFT10 over here: 
   <a href="http://www.fftw.org/doc/1d-Real_002deven-DFTs-_0028DCTs_0029.html">http://www.fftw.org/doc/1d-Real_002deven-DFTs-_0028DCTs_0029.html</a>
<a name="signal.idct3"></a></p>

<h3>signal.idct3(input)</h3>

<p>inverse 3D Discrete Cosine Transform (DCT)
   Takes Real inputs (3D tensor of NxMxP points)</p>

<p>To see what is exactly computed, see section REDFT01 over here: 
   <a href="http://www.fftw.org/doc/1d-Real_002deven-DFTs-_0028DCTs_0029.html">http://www.fftw.org/doc/1d-Real_002deven-DFTs-_0028DCTs_0029.html</a>
<a name="signal.hilbert"></a></p>

<h3>signal.hilbert(xr)</h3>

<p>Discrete-time analytic signal using Hilbert transform
   Takes 1D inputs</p>

<p>Output matches with matlab output</p>
</div>
</section>
</div>
</body>
</html>
